<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" type="image/png" href="studio_logo.png">
<meta charset="UTF-8">
<title>HUNT THE ENEMIES - beta</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #222;
    color: white;
    font-family: sans-serif;
  }
  #gameCanvas {
    display: block;
    background: #333;
    margin: auto;
  }
  .overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    background: rgba(0, 0, 0, 0.7);
    z-index: 10;
    color: white;
    font-size: 24px;
  }
  .hidden { display: none; }
  button {
    background: #444;
    color: white;
    padding: 10px 20px;
    font-size: 18px;
    border: none;
    margin-top: 15px;
    cursor: pointer;
  }
  button:hover { background: #666; }
</style>
</head>
<body>

<canvas id="gameCanvas" width="1200" height="700"></canvas>

<div id="victoryOverlay" class="overlay hidden">
  <div>ðŸŽ‰ VICTORY! All enemies eliminated ðŸŽ‰</div>
  <button onclick="restartGame()">Respawn</button>
</div>

<div id="gameOverOverlay" class="overlay hidden">
  <div>ðŸ’€ GAME OVER ðŸ’€</div>
  <button onclick="restartGame()">Respawn</button>
</div>

<script>
// ============================
// CONFIG
// ============================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const mapWidth = 2000; // marriage hall size
const mapHeight = 1500;

const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

// ============================
// PLAYER
// ============================
const player = {
  x: 200,
  y: 200,
  w: 30,
  h: 30,
  speed: 3.5,
  color: "lime",
  hp: 100,
  attackCooldown: 0
};

// ============================
// ENEMIES
// ============================
let enemies = [];

function spawnEnemies() {
  enemies = [
    { x: 800, y: 400, w: 30, h: 30, color: "red", hp: 100, dir: 0, visionRange: 300, visionAngle: Math.PI/4, state: "patrol", patrolDir: 1, cooldown: 0 },
    { x: 1200, y: 900, w: 30, h: 30, color: "red", hp: 100, dir: Math.PI, visionRange: 300, visionAngle: Math.PI/4, state: "patrol", patrolDir: -1, cooldown: 0 },
    { x: 1600, y: 500, w: 30, h: 30, color: "red", hp: 100, dir: Math.PI/2, visionRange: 300, visionAngle: Math.PI/4, state: "patrol", patrolDir: 1, cooldown: 0 }
  ];
}

// ============================
// WALLS
// ============================
const walls = [
  {x: 0, y: 0, w: mapWidth, h: 20},
  {x: 0, y: mapHeight-20, w: mapWidth, h: 20},
  {x: 0, y: 0, w: 20, h: mapHeight},
  {x: mapWidth-20, y: 0, w: 20, h: mapHeight},
  // inner walls
  {x: 400, y: 200, w: 300, h: 20},
  {x: 900, y: 400, w: 20, h: 300},
  {x: 1300, y: 700, w: 400, h: 20}
];

// ============================
// BULLETS
// ============================
let bullets = [];

// ============================
// CAMERA
// ============================
let camX = 0, camY = 0;

// ============================
// GAME STATE
// ============================
let gameOver = false;
let victory = false;

// ============================
// FUNCTIONS
// ============================
function rectsCollide(a, b) {
  return a.x < b.x + b.w &&
         a.x + a.w > b.x &&
         a.y < b.y + b.h &&
         a.y + a.h > b.y;
}

function moveEntity(entity, dx, dy) {
  entity.x += dx;
  for (let wall of walls) {
    if (rectsCollide(entity, wall)) {
      if (dx > 0) entity.x = wall.x - entity.w;
      if (dx < 0) entity.x = wall.x + wall.w;
    }
  }
  entity.y += dy;
  for (let wall of walls) {
    if (rectsCollide(entity, wall)) {
      if (dy > 0) entity.y = wall.y - entity.h;
      if (dy < 0) entity.y = wall.y + wall.h;
    }
  }
}

function playerAttack() {
  if (player.attackCooldown > 0) return;
  player.attackCooldown = 30;
  for (let e of enemies) {
    if (Math.hypot(e.x - player.x, e.y - player.y) < 50) {
      e.hp -= 50;
    }
  }
}

function enemyAI(e) {
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);
  const angleToPlayer = Math.atan2(dy, dx);
  const angleDiff = Math.abs(((angleToPlayer - e.dir + Math.PI) % (2*Math.PI)) - Math.PI);

  if (dist < e.visionRange && angleDiff < e.visionAngle) {
    // vision clear?
    let visionClear = true;
    for (let wall of walls) {
      if (lineIntersectsRect(e.x+e.w/2, e.y+e.h/2, player.x+player.w/2, player.y+player.h/2, wall)) {
        visionClear = false;
        break;
      }
    }
    if (visionClear) {
      e.state = "chase";
    }
  }

  if (e.state === "chase") {
    const dirX = Math.cos(angleToPlayer);
    const dirY = Math.sin(angleToPlayer);
    moveEntity(e, dirX * 2, dirY * 2);
    e.dir = angleToPlayer;

    if (dist < 250) {
      if (e.cooldown <= 0) {
        bullets.push({x: e.x+e.w/2, y: e.y+e.h/2, dx: dirX*5, dy: dirY*5, w: 5, h: 5, from: "enemy"});
        e.cooldown = 50;
      }
    }
  } else {
    // patrol
    moveEntity(e, Math.cos(e.dir) * 1, Math.sin(e.dir) * 1);
  }

  if (e.cooldown > 0) e.cooldown--;
}

function lineIntersectsRect(x1, y1, x2, y2, rect) {
  const lines = [
    [rect.x, rect.y, rect.x+rect.w, rect.y],
    [rect.x+rect.w, rect.y, rect.x+rect.w, rect.y+rect.h],
    [rect.x+rect.w, rect.y+rect.h, rect.x, rect.y+rect.h],
    [rect.x, rect.y+rect.h, rect.x, rect.y]
  ];
  for (let [lx1, ly1, lx2, ly2] of lines) {
    if (linesIntersect(x1, y1, x2, y2, lx1, ly1, lx2, ly2)) return true;
  }
  return false;
}

function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
  const denom = (y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1);
  if (denom === 0) return false;
  const ua = ((x4 - x3)*(y1 - y3) - (y4 - y3)*(x1 - x3)) / denom;
  const ub = ((x2 - x1)*(y1 - y3) - (y2 - y1)*(x1 - x3)) / denom;
  return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
}

// ============================
// GAME LOOP
// ============================
function update() {
  if (gameOver || victory) return;

  // movement
  let dx = 0, dy = 0;
  if (keys["ArrowUp"] || keys["w"]) dy -= player.speed;
  if (keys["ArrowDown"] || keys["s"]) dy += player.speed;
  if (keys["ArrowLeft"] || keys["a"]) dx -= player.speed;
  if (keys["ArrowRight"] || keys["d"]) dx += player.speed;
  moveEntity(player, dx, dy);

  if (keys[" "]) playerAttack();
  if (player.attackCooldown > 0) player.attackCooldown--;

  for (let e of enemies) {
    if (e.hp > 0) enemyAI(e);
  }

  // bullets
  for (let b of bullets) {
    b.x += b.dx;
    b.y += b.dy;
    // wall collision
    let remove = false;
    for (let wall of walls) {
      if (rectsCollide(b, wall)) {
        remove = true;
        break;
      }
    }
    if (b.from === "enemy" && rectsCollide(b, player)) {
      player.hp -= 20;
      remove = true;
      if (player.hp <= 0) gameOver = true;
    }
    if (b.from === "player") {
      for (let e of enemies) {
        if (rectsCollide(b, e) && e.hp > 0) {
          e.hp -= 50;
          remove = true;
          break;
        }
      }
    }
    b.remove = remove;
  }
  bullets = bullets.filter(b => !b.remove);

  // victory check
  if (enemies.every(e => e.hp <= 0)) victory = true;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  camX = player.x - canvas.width/2;
  camY = player.y - canvas.height/2;
  if (camX < 0) camX = 0;
  if (camY < 0) camY = 0;
  if (camX > mapWidth - canvas.width) camX = mapWidth - canvas.width;
  if (camY > mapHeight - canvas.height) camY = mapHeight - canvas.height;

  ctx.save();
  ctx.translate(-camX, -camY);

  // walls
  ctx.fillStyle = "#555";
  for (let wall of walls) {
    ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
  }

  // player
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.w, player.h);

  // enemies
  for (let e of enemies) {
    if (e.hp > 0) {
      ctx.fillStyle = e.color;
      ctx.fillRect(e.x, e.y, e.w, e.h);
      // vision cone
      ctx.fillStyle = "rgba(255,255,255,0.2)";
      ctx.beginPath();
      ctx.moveTo(e.x+e.w/2, e.y+e.h/2);
      ctx.arc(e.x+e.w/2, e.y+e.h/2, e.visionRange, e.dir - e.visionAngle, e.dir + e.visionAngle);
      ctx.closePath();
      ctx.fill();
    }
  }

  // bullets
  ctx.fillStyle = "yellow";
  for (let b of bullets) {
    ctx.fillRect(b.x, b.y, b.w, b.h);
  }

  ctx.restore();

  // HUD
  ctx.fillStyle = "white";
  ctx.fillText(`HP: ${player.hp}`, 20, 20);
}

function gameLoop() {
  update();
  draw();
  document.getElementById("victoryOverlay").classList.toggle("hidden", !victory);
  document.getElementById("gameOverOverlay").classList.toggle("hidden", !gameOver);
  requestAnimationFrame(gameLoop);
}

function restartGame() {
  player.x = 200;
  player.y = 200;
  player.hp = 100;
  player.attackCooldown = 0;
  bullets = [];
  spawnEnemies();
  gameOver = false;
  victory = false;
}

spawnEnemies();
gameLoop();
</script>

</body>
</html>
